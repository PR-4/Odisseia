# -*- coding: utf-8 -*-
"""código_ic2.ipynb
Autor(a): Layra
Automatically generated by Colaboratory.
Original file is located at
    https://colab.research.google.com/drive/1LqO4TBtrUc0rojI4taoPIhagejsk8hhC
"""
# EXTRAINDO AS CURVAS DOS DLIS

### IMPORTANDO AS BIBLIOTECAS NECESSÁRIAS

import glob
from dlisio import dlis
import pandas as pd
import re
import matplotlib.pyplot as plt
# modulos internos
import sys
sys.path.insert(0,'../modules')
from imod import Debug as db
from graficador import plotagem as plm2

### LENDO OS ARQUIVOS DLIS

path = '../inputs'

lista_dlis = []
lista_read = []



#importando todos os arquivos dlis da pasta 'dlis'
for v, path_dlis in enumerate(glob.glob(f'{path}/*dlis')):
    lista_dlis.append(f'dlis_{v}')
    lista_read.append(path_dlis)

dicio_dlis = dict(zip(lista_dlis, lista_read))

#lendo os arquivos dlis com a biblioteca dlisio
lista_logicos1 = []
for i, v in dicio_dlis.items():
    f, *tail = dlis.load(dicio_dlis[i]) #f  primeiro arquivo lógico do dlis, tail lista contendo os demais lógicos
    tail.append(f)
    #colocando todos os arquivos lógicos na lista_logicos1 
    lista_logicos1.append(tail)

#print(dicio_dlis)
#print(lista_logicos1)


#função para transformar listas encadeadas em listas
from collections import Iterable
def flatten(lis):
     for item in lis:
         if isinstance(item, Iterable) and not isinstance(item, str):
             for x in flatten(item):
                 yield x
         else:        
             yield item

lista_logicos2 = list(flatten(lista_logicos1))

print(lista_logicos2)





### VENDO O CABEÇALHO DOS 4 PRIMEIROS ARQUIVOS LÓGICOS DA LISTA

origin, *origin_tail = lista_logicos2[0].origins
#print(origin.describe())

origin2, *origin_tail2 = lista_logicos2[1].origins
#print(origin2.describe())

origin3, *origin_tail3 = lista_logicos2[2].origins
#print(origin3.describe())

#A partir dessa quarto lógico, o cabeçalho é o mesmo.
origin4, *origin_tail4 = lista_logicos2[2].origins
#print(origin4.describe())


### EXTRAINDO OS FRAMES DOS ARQUIVOS LÓGICOS"""

lista_frames = []
for i in lista_logicos2:
    for fr in i.frames:
        lista_frames.append(fr)

#print(lista_frames)



#manipulação para remover os frames duplicados
df_frames = pd.DataFrame(lista_frames, index = lista_frames)
df_frames.index = df_frames.index.astype('string')
df_frames = df_frames[~df_frames.index.duplicated(keep = 'first')]

lista_frames2 = df_frames[0].to_list()

#print(lista_frames2)


#extraindo somente as strings que estão dentro dos parênteses
lista_frames3 = []
for frame in lista_frames2:
       lista_frames3.append(str(frame)[str(frame).find("(")+1:str(frame).find(")")])

#print(lista_frames3)



### EXTRAINDO OS CANAIS (CURVAS) DOS ARQUIVOS LÓGICOS """

canais = []
for i in lista_logicos2:
    canais.append(i.channels)

canais = list(flatten(canais))

#print(canais)


#extraindo somente as strings entre parênteses
canais2 = []
for ch in canais:
       canais2.append(str(ch)[str(ch).find("(")+1:str(ch).find(")")])

#print(canais2)

#revomendo os canais duplicados e colocando em ordem alfabetica
canais3 = list(sorted(set(canais2)))

#print(canais3)



# Até aqui está ok! 

## EXTRAINDO AS CURVAS E TRANSFORMANDO EM DATAFRAMES"""


#canais_alvo = ['RT','DT']


#lista_curvas = []

#for i in lista_logicos2: # ERRO!!!!!! Qual lista a iterar logicos 1 ou 2 ? Estava lista_logicos, variável não definida.
    
#    for fr in lista_frames3:
        
#        try:
            
            #pegando as curvas de todos os frames
#            frame = i.object('FRAME', fr)
#            curves = frame.curves()
        
#        except Exception as err: 

            #print(f' *O arquivo {i}, possui o erro: {err}*')
#            pass
         
#        for v in canais3:
                
#            try:
                #colocando o nome da curva como o nome da curva + nome do logico  + nome do frame
#                curva_name = v + '_' + str(i) + '_' + str(fr)
                #transformando as curvas em dataframes, onde o index é o TDEP convertido para metros
#                curvas = pd.DataFrame(curves[v], columns = [curva_name], index = curves['TDEP']*0.00254)
                #colocando todos os dataframes em uma lista de dataframes
#                lista_curvas.append(curvas)
                #O asteristico alerta para quais lógicos possuem as curvas
                #print(f'** O arquivo {i} possui a curva {v}')


#            except Exception as e: 

                #print(f' O arquivo {i}, possui o erro: {e}')
#                pass


#removendo as linhas com indices duplicados (são valores constantes realmente removidos das análises)
#lista_curvas2 = []
#for i in lista_curvas:
#    lista_curvas2.append(i.reset_index().drop_duplicates(subset='index', keep='last').set_index('index').sort_index())

#print(lista_curvas2)# retorna vazia # quando eu itero com o lista_logicos2 funciona! Confirmar isso hoje!

#print(len(lista_curvas2))# retorna vazio


#pegando alguns dataframes para teste
#lis = [lista_curvas2[0], lista_curvas2[1000], lista_curvas2[3000]]


#concatenando a lista de teste
#curvas = pd.concat(lis, axis = 1)
#curvas2 = pd.concat(lista_curvas2, axis = 1)


#print(curvas)
#print(curvas2)

# ### CRIANDO UM DATAFRAME COM TODOS OS CANAIS E SEUS RESPECTIVOS "LONG NAMES"

df = pd.DataFrame() #O dataframe precisa ser definido fora do laço

def summary_dataframe(object, **kwargs):
    # Create an empty dataframe
    df = pd.DataFrame()
    
    # Iterate over each of the keyword arguments
    for i, (key, value) in enumerate(kwargs.items()):
        list_of_values = []
        
        # Iterate over each parameter and get the relevant key
        for item in object:
            # Account for any missing values.
            try:
                x = getattr(item, key)
                list_of_values.append(x)
            except:
                list_of_values.append('')
                continue
        
        # Add a new column to our data frame
        df[value]=list_of_values
    
    # Sort the dataframe by column 1 and return it
    return df.sort_values(df.columns[0])



pd.set_option('display.max_rows',7000)

print(type(lista_logicos2[0]))


#channels = summary_dataframe(f.channels, name='Name', long_name='Long Name',
#                             dimension='Dimension', units='Units', frame='Frame')
#print(channels)

lista_sumario = []
for i in lista_logicos2:
    lista_sumario.append(summary_dataframe(i.channels, name='Name',long_name='Long Name', dimension='Dimension',
        units= 'Units', frame= 'Frame'))

channels = pd.concat(lista_sumario)
print(channels)

# ### FUNÇÃO PARA FILTRAR A PALAVRA ESCOLHIDA (PARÂMETRO FÍSICO) E RETORNAR UMA LISTA COM O NOME DOS CANAIS DO RESPECTIVO PARÂMETRO



def lista_canais(dataframe, nome_canal): # não está fazendo para outras propriedades
    df_novo = dataframe[dataframe['Long Name'].str.contains(nome_canal)]
    lista = df_novo['Name'].to_list()
    return lista



#lista_gamma = lista_canais('Resistivity','Sonic','Gamma')
#print(lista_gamma)

#Lista que deve conter os nomes das propriedades físicas que o usuário deseja salvar
propriedades = ['Resistivity','Sonic','Gamma']


lista_alvo = []
for i in propriedades:
    lista_alvo.append(lista_canais(channels,i))

lista_alvo = list(flatten(lista_alvo))

print(lista_alvo)

#FUNÇÃO PARA REMOVER VALORES REPETIDOS

def remove_repetidos(lista):
    l = []
    for i in lista:
        if i not in l:
            l.append(i)
    l.sort()
    return l


# In[125]:


#lista_gamma = remove_repetidos(lista_gamma)
#print(lista_gamma)

lista_alvo = remove_repetidos(lista_alvo)
print(lista_alvo)


# ### APLICANDO O CÓDIGO NA NOVA LISTA


lista_curvas = []

for i in lista_logicos2:
    
    for fr in lista_frames3:
        
        try:
            
            #pegando as curvas de todos os frames
            frame = i.object('FRAME', fr)
            curves = frame.curves()
        
        except Exception as err: 

            print(f' *O arquivo {i}, possui o erro: {err}*')
            pass
         
        for v in lista_alvo: ###AQUI QUE APLICA A NOVA LISTA <-----------------------------
                
            try:
                #colocando o nome da curva como o nome da curva + nome do logico  + nome do frame
                curva_name = v + '_' + str(i) + '_' + str(fr)
                #transformando as curvas em dataframes, onde o index é o TDEP convertido para metros
                curvas = pd.DataFrame(curves[v], columns = [curva_name], index = curves['TDEP']*0.00254)
                #colocando todos os dataframes em uma lista de dataframes
                lista_curvas.append(curvas)
                #para alertar quais lógicos possuem as curvas
                print(f'** O arquivo {i} possui a curva {v}')


            except Exception as e: 

                print(f' O arquivo {i}, possui o erro: {e}')
                pass

# In[131]:


lista_curvas2 = []
for i in lista_curvas:
    lista_curvas2.append(i.reset_index().drop_duplicates(subset='index', keep='last').set_index('index').sort_index())


# In[132]:


curvas_alvo = pd.concat(lista_curvas2, axis = 1)
print(curvas_alvo)

# In[134]:


curvas_alvo = curvas_alvo.reset_index()


#print(curvas_gamma)
#print(type(curvas_gamma))



#Visualização das curvas


#plt.plot(curvas_gamma['index'], curvas_gamma['ECGR_LogicalFile(RFT_041LUP)_60B'])




#padrao={'comprimento':15,
#            'altura':15
#}
#Desenha os plots
#figure2 = plm2(2, padrao)
#figure2.plot_s(0,lista_curvas2[1000],lista_curvas2[0],{'titulo':'Densidade  \n  (g\cm³) ','cor':'k','descricao_x':'(a)'})
#figure2.plot_s(1,lista_curvas2[3000],lista_curvas2[0],{'titulo':'Idade \n (Ma)','cor':'k','descricao_x':'(b)'})

#figure2.legenda({'ancoragem':(-0.3, 0.09, 3.0, -0.16),'colunas':2,'ordem':[0,1,2,3,4,5,6,7] })

#plt.savefig('../images/curvas.jpg', dpi=150, bbox_inches = 'tight', 
#            facecolor='w', edgecolor='w',transparent = True)

#Salva o Dataframe:

curvas_alvo.to_excel("../outputs/canais_alvo.xlsx",index=True)
curvas_alvo.to_csv("../outputs/canais_alvo.txt",index=True)




