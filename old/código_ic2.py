# -*- coding: utf-8 -*-
"""código_ic2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LqO4TBtrUc0rojI4taoPIhagejsk8hhC

# EXTRAINDO AS CURVAS DOS DLIS

### IMPORTANDO AS BIBLIOTECAS NECESSÁRIAS
"""

import glob
from dlisio import dlis
import pandas as pd
import re

"""### LENDO OS ARQUIVOS DLIS"""

path = 'dlis'

lista_dlis = []
lista_read = []

#importando todos os arquivos dlis da pasta 'dlis'
for v, path_dlis in enumerate(glob.glob(f'{path}/*dlis')):
    lista_dlis.append(f'dlis_{v}')
    lista_read.append(path_dlis)

dicio_dlis = dict(zip(lista_dlis, lista_read))

#lendo os arquivos dlis com a biblioteca dlisio
lista_logicos1 = []
for i, v in dicio_dlis.items():
    f, *tail = dlis.load(dicio_dlis[i])
    tail.append(f)
    #colocando todos os arquivos lógicos na lista_logicos1 
    lista_logicos1.append(tail)

lista_logicos1

#função para transformar listas encadeadas em listas
from collections import Iterable
def flatten(lis):
     for item in lis:
         if isinstance(item, Iterable) and not isinstance(item, str):
             for x in flatten(item):
                 yield x
         else:        
             yield item

lista_logicos2 = list(flatten(lista_logicos1))

lista_logicos2

"""### VENDO O CABEÇALHO DOS 4 PRIMEIROS ARQUIVOS LÓGICOS DA LISTA"""

origin, *origin_tail = lista_logicos2[0].origins

origin.describe()

origin2, *origin_tail2 = lista_logicos2[1].origins
origin2.describe()

origin3, *origin_tail3 = lista_logicos2[2].origins
origin3.describe()

#A partir dessa quarto lógico, o cabeçalho é o mesmo.
origin4, *origin_tail4 = lista_logicos2[2].origins
origin4.describe()

"""### EXTRAINDO OS FRAMES DOS ARQUIVOS LÓGICOS"""

lista_frames = []
for i in lista_logicos2:
    for fr in i.frames:
        lista_frames.append(fr)

lista_frames

#manipulação para remover os frames duplicados
df_frames = pd.DataFrame(lista_frames, index = lista_frames)
df_frames.index = df_frames.index.astype('string')
df_frames = df_frames[~df_frames.index.duplicated(keep = 'first')]

lista_frames2 = df_frames[0].to_list()

lista_frames2

#extraindo somente as strings que estão dentro dos parênteses
lista_frames3 = []
for frame in lista_frames2:
       lista_frames3.append(str(frame)[str(frame).find("(")+1:str(frame).find(")")])

lista_frames3

"""### EXTRAINDO OS CANAIS (CURVAS) DOS ARQUIVOS LÓGICOS """

canais = []
for i in lista_logicos2:
    canais.append(i.channels)

canais = list(flatten(canais))

canais

#extraindo somente as strings entre parênteses
canais2 = []
for ch in canais:
       canais2.append(str(ch)[str(ch).find("(")+1:str(ch).find(")")])

canais2

#revomendo os canais duplicados e colocando em ordem alfabetica
canais3 = list(sorted(set(canais2)))

canais3

"""## EXTRAINDO AS CURVAS E TRANSFORMANDO EM DATAFRAMES"""

lista_curvas = []

for i in lista_logicos:
    
    for fr in lista_frames3:
        
        try:
            
            #pegando as curvas de todos os frames
            frame = i.object('FRAME', fr)
            curves = frame.curves()
        
        except Exception as err: 

            print(f' *O arquivo {i}, possui o erro: {err}*')
            pass
         
        for v in canais3:
                
            try:
                #colocando o nome da curva como o nome da curva + nome do logico  + nome do frame
                curva_name = v + '_' + str(i) + '_' + str(fr)
                #transformando as curvas em dataframes, onde o index é o TDEP convertido para metros
                curvas = pd.DataFrame(curves[v], columns = [curva_name], index = curves['TDEP']*0.00254)
                #colocando todos os dataframes em uma lista de dataframes
                lista_curvas.append(curvas)
                #para alertar quais lógicos possuem as curvas
                print(f'** O arquivo {i} possui a curva {v}')


            except Exception as e: 

                print(f' O arquivo {i}, possui o erro: {e}')
                pass

#removendo as linhas com indices duplicados (são valores constantes realmente removidos das análises)
lista_curvas2 = []
for i in lista_curvas:
    lista_curvas2.append(i.reset_index().drop_duplicates(subset='index', keep='last').set_index('index').sort_index())

lista_curvas2

len(lista_curvas2)

#pegando alguns dataframes para teste
lis = [lista_curvas2[0], lista_curvas2[1000], lista_curvas2[3000]]

#concatenando a lista de teste
curvas = pd.concat(lis, axis = 1)

curvas